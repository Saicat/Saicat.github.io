---
title: 训练数据合成(三)
tags:
  - NLP
  - LLM
  - transformer
  - 预训练
  - 数据合成
categories:
  - CS
  - NLP
  - LLM
abbrlink: e259c7b2
date: 2024-11-17 21:46:36
---

【本文已在同名 微信公众号 / 知乎 / [个人博客linsight.cn](http://www.linsight.cn/) 上线】  

***  

书接上回，[训练数据合成(二)](https://www.linsight.cn/85132189.html)，继续看一些数据合成相关工作，这次很多都是和代码相关的。  

# CodeLLMs的数据合成综述  

论文：《Mastering the Craft of Data Synthesis for CodeLLMs》  

时间：2024年10月  

这是一篇关于代码模型中所使用的数据合成方法的综述。根据不同的分类维度，各个代码数据合成相关工作被分类成以下这样：  

{% asset_img survey_classes.png 数据合成 %}  

## Preliminaries  

先科普一下CodeLLMs通常的data curation pipeline。一般有这么四个step：  
- Seed Input Collection：收集原始启动数据，用于指导、启发数据合成  
- Data Synthesis：合成新数据的过程  
- Data Filtering：过滤掉低质量、不符合要求的合成数据，避免引入幻觉等问题  
- Data Evaluation：验证得到的数据的效果，通常需要训练模型验证  

{% asset_img survey_pipeline.png 数据合成 %}  

## Data Synthesis Techniques  

如图1，综述从三个维度来划分代码数据合成的方法，从里面提取了一些工作出来看看。  

### Model Building Phases 维度  

首先是按模型训练阶段划分。  

1、预训练  

- Phi系列工作（《Textbooks Are All You Need》），通过合成的教科书进行预训练，用少量的数据就能到比较好的效果  
- CodeLlama提出代码执行反馈的方法，提高数据质量  
- 《Instruction pretraining: Language models are supervised multitask learners》用instruction synthesizer从无监督数据获取instruction-response pair，使用量级更小的instruction数据进行预训练就能获得比同量级下无监督数据更好的效果  

2、SFT  

- 经典工作Self-Instruct & Evol-Instruct  
- Magicoder利用OSS-INSTRUCT的方法（OSS=open-source code snippets），合成了75k的指令数据，并获得了不错的效果。  
- Auto Evol-Instruct：《Automatic instruction evolving for large language models》，可以自动端到端进行指令进化  
- WaveCoder：《WaveCoder: Widespread and versatile enhancement for code large language models by instruction tuning》，合成CodeSeaXDataset，涵盖了代码摘要、生成、翻译和修复等任务。  
- Semcoder：《Semcoder: Training code language models with comprehensive semantics》，合成PyX数据集  
- Autocoder：《Autocoder: Enhancing code large language model with AIEV-INSTRUCT》，引入了AIEV-INSTRUCT，一个 two-stage agent interaction framework  

3、Preference alignment  

- CodeUltraFeedback：偏好数据集  
- PLUM：用于训练 CodeLLM 的偏好学习框架  

### Core Objectives 维度  

1、Quality  

- 《LLM-assisted code cleaning for training accurate code generators》通过增强代码结构和可读性来提高质量  
- 《Personalized distillation: Empowering opensourced LLMs with adaptive learning for code generation》  
- 《Language models can teach themselves to program better》使用self-play来增强CodeLLM  
- Autocoder通过模拟人类编写代码 + 单元测试执行反馈来获得高质量数据  

2、Diversity  

《What makes good data for alignment? a comprehensive study of automatic data selection in instruction tuning》和《#instag: Instruction tagging for analyzing supervised fine-tuning of large language models》都指出数据多样性对模型alignment的影响很大。  

- MagicCoder从真实数据里采样来提升多样性  
- 《Automatic instruction evolving for large language models》用LLM自主设计计划规则  
- WaveCoder用KCenterGreedy算法选择多样化样本  
- 《Training language models on synthetic edit sequences improves code synthesis》

3、Reasoning  

- 《LLM-assisted code cleaning for training accurate code generators》对function进行summarization，并加到注释里  
- Semcoder模仿“小黄鸭调试法”逐步解释代码  
- 《Enhancing code generation performance of smaller models by distilling the reasoning ability of LLMs》从已有代码生成plan，用plan和代码在微调代码生成模型  
- 《Beyond code: Evaluate thought steps for complex code generation》利用ChatGPT获得为复杂代码生成的复杂步骤  
- Case2code帮助模型提高归纳推理能力  

4、Iterative programming  

有些情况下单步无法获得正确代码，需要迭代修改。  

- 《OpenCodeInterpreter: Integrating code generation with execution and refinement》给出Code-Feedback数据集，包含68,000次交互，反复迭代修改代码。  
- 《Semcoder》引入了 PyX-R 调试数据集，其中包含描述、错误代码、跟踪和reasoning，用于训练 LLM 进行调试和自我改进。  
- 《Cycle: Learning to self-refine the code generation》通过整合问题描述、已有代码和执行反馈来改进有缺陷的代码。  
- 《LETI: Learning to generate from textual interactions》使用自然语言指令、生成的代码和来自error的文本反馈来微调模型。  
- 《Reflexion: language agents with verbal reinforcement learning》使用口头和启发式反馈来强化language agents。  

### 其他特别任务  

包括  

- NL2SQL  
- 代码修复  
- 代码翻译  
- 代码重构  

等特别任务，都分别有一些数据相关工作。  

## Data Filtering Techniques  

合成的数据往往混杂着badcase，因此数据过滤就很重要。  

1、基于规则  

比如太长的行、太长的文件、字母字符太少等过滤规则。  

另外还是有SimHash + LSH的去重。  

2、基于interpreter  

通过代码解释器执行反馈。  

3、基于SLM  

使用小模型进行数据过滤，效果可以超过规则或者代码解释器的方法。  

- 《Superfiltering: Weak-to-strong data filtering for fast instruction-tuning》评估了弱模型和强模型之间的一致性，以确定指令调优样本的难度，证明指令遵循难度 (IFD) 分数在捕捉样本复杂性方面优于困惑度。  
- 《Instruction mining: Instruction data selection for tuning large language models》利用自然语言指标来预测推理损失，这比微调 LLM 提供了更有效的评估数据的方法。  
- 《CodeBERTScore: Evaluating code generation with pretrained models of code》用bert计算相似度。  
- 《WaveCoder》利用 KCenterGreedy 算法来选择近似于完整分布的数据子集。  
- Llama-3则是利用fasttext、Roberta等来识别高质量的token。  

4、基于LLM  

- 《Alpagasus: Training a better alpaca with fewer data》利用 ChatGPT 作为评分器。  
- 《ICE-score: Instructing large language models to evaluate code》通过 LLM 评估代码有用性和功能正确性。  
- 《WaveCoder》使用 GPT-4 作为鉴别器来分析和过滤指令数据，利用 CoT 推理逐步评估每个实例，将它们分类为有效或无效。  
- Llama-3用早期的Llama版本对代码的正确定和风格进行打分。  

# Instruction Pre-Training  

论文：《Instruction Pre-Training: Language Models are Supervised Multitask Learners》  

时间：2024年6月  

机构：清华，微软  

模型、代码、数据都在https://github.com/microsoft/LMOps/tree/main/instruction_pretrain可找，instruction-synthesizer也在https://huggingface.co/instruction-pretrain/instruction-synthesizer了，可以直接下下来使用。  

近些年来大模型的成功主要得益于大规模的无监督预训练，但是一些工作如《Scaling instruction-finetuned language models》证明了有监督多任务学习还是有价值的。Instruction Pre-Training这篇论文就通过使用instruction-synthesizer把无监督数据增强为instruction-response pair，再进行有监督多任务训练，来获得不错的效果。  

{% asset_img instructionpt_intro.png 数据合成 %}  

## Instruction Synthesizer  

《Skill-it! A Data-Driven Skills Framework for Understanding and Training Language Models》的分析表明，raw corpora里包含很多intrinsic task，这也是能够从无监督数据中获取instruction数据的前提。  

用于从无监督数据合成instruction数据的模型叫instruction synthesizer，它是从通用LLM进行multi-task fine-tuning得到的：  

{% asset_img instructionpt_tune.png 数据合成 %}  

微调synthesizer的数据保证了多样性，使得instruction synthesizer有比较好的泛化性。收集的数据和任务包括以下这些：  

{% asset_img instructionpt_data.png 数据合成 %}  

微调instruction synthesizer的时候训练数据被组织成few-shot examples的样式，多个example都来自同一个数据集，这样能保证任务格式和任务类别的一致性。计算loss的时候只算了instruction-response pairs部分token的loss。  

推理的时候也是用类似的方式，通过把多轮的结果concat起来能够得到few-shot example的prompt。  

{% asset_img instructionpt_syn.png 数据合成 %}  

为了方便提取合成的数据，实验中给各个任务设计了不同的模板，用一些特殊的token帮助区分各个成分：  

{% asset_img instructionpt_template.png 数据合成 %}  

实验上使用的synthesizer模型是Mistral-7B-v0.1。在数据合成中，平均每段无监督文本能创建大约5对数据，每对数据的长度52个token。训练的参数如下：  

{% asset_img instructionpt_hyperparam.png 数据合成 %}  

## LM Pre-Training  

获得instruction-response数据后，参考《The flan collection: Designing data and methods for effective instruction tuning》的模板来提升指令格式的多样化。另外还采用《Adapting large language models via reading comprehension》里的模板把原始文本和instruction-response数据合到一起训练。按上图inference的得到的结果，同样的M-shot prompt也用来训练。  

instruction pre-training除了数据不同外，其他训练配置保持和无监督训练一样。实验中文章使用了两种方式：从零预训练和（domain-adaptive）继续预训练。  

由于instruction数据在数据量上相对还是比无监督数据少很多，所以从零预训练的时候采用两种数据混合的方式。实验上无监督数据的数据量是100B token，而指令数据约0.8B token。  

而继续预训练也不只使用这里生成的指令数据，而会和通用的指令数据混在一起，混合的比例参考《Adapting large language models via reading comprehension》。  

## 效果  

在通用领域上，不同训练方式下的效果：  

{% asset_img instructionpt_perf.png 数据合成 %}  

和外部模型对比：  

{% asset_img instructionpt_perf_2.png 数据合成 %}  

看起来在某些任务略有提升吧，似乎不太明显。  

而domain-specific的task上，提升可能更明显一点：  

{% asset_img instructionpt_domain_perf.png 数据合成 %}  

毕竟合成的数据量相对来说还是比较少，专注在少量方向效果更好。  

# Auto Evol-Instruct  

auto evol-instruct可以说是evol-instruct的升级版、自动版，不过auto evol-instruct主要目的是提升instruct的复杂性，多样性上可能没有特别关注。  

原本evol-instruct需要人为设计进化的具体方向，这样在数据/领域变更的时候就不太方便（比如“提高空间复杂度/时间复杂度要求”的限制在code领域很合理，但是在情感分析领域就没什么意义）。而auto evol-instruct提出的方法可以自动适配到不同的数据，而不需要人工修改。  

大致的方法如下：  

{% asset_img auto_evol_intro.png 数据合成 %}  

首先，会有一个initial进化方法，进化所使用的prompt如下：  

```python
You are an Instruction Rewriter that rewrites the given #Instruction# into a more complex version.
Please follow the steps below to rewrite the given "#Instruction#" into a more complex version.
Step 1: Please read the "#Instruction#" carefully and list all the possible methods to make this instruction more complex (to make it a bit harder for well-known AI assistants such as ChatGPT and GPT4 to handle). Please do not provide methods to change the language of the instruction!
Step 2: Please create a comprehensive plan based on the #Methods List# generated in Step 1 to make the #Instruction# more complex. The plan should include several methods from the #Methods List#.
Step 3: Please execute the plan step by step and provide the #Rewritten Instruction#. #Rewritten Instruction# can only add 10 to
20 words into the "#Instruction#".
Step 4: Please carefully review the #Rewritten Instruction# and identify any unreasonable parts. Ensure that the #Rewritten Instruction# is only a more complex version of the #Instruction#. Just provide the #Finally Rewritten Instruction# without any
explanation.
Please reply strictly in the following format:
Step 1 #Methods List#:
Step 2 #Plan#:
Step 3 #Rewritten Instruction#:
Step 4 #Finally Rewritten Instruction#:
#Instruction#:
{Instruction}
```  

auto evol-instruct会迭代多轮来优化进化方法（也就是上面这个prompt）。在每一轮中，会从前一轮数据集中随机抽样一小批指令，并对每个指令类进行l次进化，这l次进化就构成Evol Trajectory。  

对于被进化后的指令，用optimizer LLM进行分析，找到本次进化中这些指令中存在的问题。optimizer LLM所用的prompt如下：  

```python
The following list shows cases where an Instruction evolves into a more complex version of an Instruction.
For each case, stage 0 represents the Instruction in its initial state, and each subsequent stage requires an increase in complexity based on the previous stage.
Please identify cases that failed to evolve, and provide their case ID and reasons.
{Evolutionary Trajectory}
```  

下面是一些进化结果分析样例：  

{% asset_img auto_evol_example.png 数据合成 %}  

收集到分析结果之后，会要求optimizer LLM来改进现有的进化方法，prompt如下：  

```python
{Feedback}
I will provide you with the method for evolving the above instructions.
You need to optimize this method based on the feedback from the evolution failure case, without harming the performance on other cases, and ensure that the complexity increase brought by the optimized method is not lower than the previous method.
Please provide the optimized method in the following format.
'''Optimized Method\n<Optimized Method Here>\n'''
{Evol Prompt}
```  

在改进进化方法的时候，optimizer LLM并不能保证总是能给出好的结果，因此这里会使用采样解码（而非贪婪解码之类的）的方式获得m个结果，这样就有m个候选的改进方案。  

这m个改进方案会分别进行验证：在特意保留的dev数据集上进化指令，并获得response。利用设计的一系列规则来判断进化是否失败，然后选择这m个候选改进中失败率最低的方案，进入下一轮优化。  

判断是否失败的规则如下：  

{% asset_img auto_evol_fail.png 数据合成 %}  

多轮迭代之后，迭代数达到设置的上限，或者指令的复杂度难以进一步进化之后，就得到了最终的进化方法。这个最终方法就会应用在所有数据上。  

# WaveCoder  

论文：《WaveCoder: Widespread And Versatile Enhancement For Code Large Language Models By Instruction Tuning》  

时间：2023年12月  

机构：清华，微软  

按照《Lima》《Instruction tuned models are quick learners》的研究结果，SFT阶段的数据质量和多样性影响很大。WaveCoder优化代码模型的工作主要就在于合成了高质量的instruction数据，数量也并不是很多，总共有19,915条。整体的流程如下：  

{% asset_img wavecoder_intro.png 数据合成 %}  

这一万多条数据主要涵盖四类代码相关任务（参考《Codexglue: A machine learning benchmark dataset for code understanding and generation》的分类）：  
- Code Generation：从文本到代码，或者从代码到代码，生成solution  
- Code Summarization：给定代码，写文本摘要  
- Code Repair：修改给定代码中的潜在问题  
- Code Translation：将一种变成语言转换成另一种  

生成的数据分布如下：  

{% asset_img wavecoder_task.png 数据合成 %}  

## 数据合成  

1、raw data 收集  

要合成数据，首先需要一些raw data。这里选择的是CodeSearchNet，它包含github上的200万个 (comment, code) pair。在这些数据里，首先过滤掉了太长或者太短的代码，然后参考《Code alpaca: An instruction-following llama model for code generation》的分析，排除掉在blacklist中的关键词，因为包含这些关键词可能会影响训练模型的效果。  

在这个基础上，为了保证原始代码数据的多样性，使用KCenterGreedy算法获取一批core samples。这样原始数据天然具有多样性，因此对后续用于合成数据的LLM和prompt的随机性和能力的要求就没那么高了。KCenterGreedy获得的数据的语言分布如下：  

{% asset_img wavecoder_lang.png 数据合成 %}  

2、Generator-Discriminator框架  

数据合成分为两个阶段：（1）Generation Phase（2）Discrimination Phase。  

（1）Generation Phase  

在这一阶段，首先用GPT-4为前面介绍的4个代码任务写定义。之后人工给每个任务添加生成的要求。这两部分内容会整合到prompt里，让ChatGPT根据raw data生成指令数据。  

{% asset_img wavecoder_framework.png 数据合成 %}  

（2）Discrimination Phase  

为了保证合成的数据质量，使用GPT-4作为判别器，分析和过滤上一步合成的数据。判别的prompt里把需要判别的内容细分成多个小点，方便模型分别给出结果，另外还会输入few-shot example，这些example不仅包含好的样本，也会包含不好的样本。一个判别的例子如下：  

{% asset_img wavecoder_example.png 数据合成 %}  

# Semcoder  

论文：《SemCoder: Training Code Language Models with Comprehensive Semantics Reasoning》  

时间：2024年6月  

Semcoder在代码数据优化上，也是以合成可执行代码为目标，因为原来的代码数据中大约有四分之一的代码是不能执行的。具体来说，Semcoder在OSS-Instruct方案的基础上进行了改进：OSS-Instruct是随机抽取一些代码片段，而Semcoder则是将raw data解析成AST，并抽取子树以获得可解析的种子。OSS-Instruct之前在《训练数据合成(一)》介绍过了。可解析的代码会被执行，可执行的代码会用LLM进行调试，直到代码可正确运行。  

Semcoder构造的数据集称为PyX，构造的大致过程如下：  

{% asset_img semcoder_intro.png 数据合成 %}  

PyX和OSS-Instruct数据集的效果对比：  

{% asset_img semcoder_compare.png 数据合成 %}  

Semcoder还在PyX基础上，模仿“小黄鸭调试法”的思路，弄了一个提升模型debug和reasoning的数据集，这个这里暂时不展开，不过“拟人”这个思路到时挺有启发性。  

# Autocoder  

论文：《AutoCoder: Enhancing Code Large Language Model with AIEV-INSTRUCT》  

时间：2024年5月  

Autocoder提出一个用于合成代码相关多轮对话数据的方法AIEV-Instruct（AIEV = Agent-Interaction and Execution-Verified）。一共合成了169k的代码指令数据，用这份数据训练的33B参数的AutoCoder，在效果上超越了2024年4月份的GPT-4o，humaneval达到90.9%。  

AIEV-Instruct分为两个阶段：（1）Teaching Stage和（2）Self-Learning Stage。第一个阶段用于让student模型从teacher模型学习知识，而当student模型的效果达到了teacher模型的水平，就需要进行自学习了。  

整体的流程如下： 

{% asset_img autocder_intro.png 数据合成 %}  

1、Teaching Stage  

在这个阶段，会用GPT-4 Turbo作为teacher model。GPT-4 Turbo会被赋予两个角色，questioner和programmer，二者会进行交互，以获得对话数据。  

在一开始，先利用GPT-4 Turbo执行OSS-Instruct方案，从raw data中设计代码问题的描述，以及solution。在这个基础上，相比原始的OSS-Instruct，这里还会生成单元测试。  

这些生成的问题描述（上图①）、solution和单元测试（上图②）会被放进对话列表中作为对话历史的一部分。之后会进行执行反馈来验证代码，如果执行发生错误，将会把具体的error信息也加入到对话信息列表中（上图③）。同时会让questioner根据报错信息生成自然语言描述，加到对话信息列表中（上图④）。之后会由programmer重新修改代码（上图⑤），并迭代这个过程，直到单元测试通过。不过这个迭代过程有最大上限，设置为7次。如果迭代其次之后代码仍然无法执行成功，那么就放弃这一条数据。  

每处理2000条数据，就会对student模型，也就是AutoCoder进行一次训练。这2000条数据会按1:9被分成验证集和训练集，如果在验证集上student model的效果超过了teacher模型，就会进入到Self-Learning Stage，否则就继续进行下一轮的Teaching Stage。  

2、Self-Learning Stage  

Self-Learning Stage所做的事情其实跟Teaching Stage基本上是一样的，只是teacher模型换成了AutoCoder自己。  

这里合成数据所使用的raw data是来自Magicoder-Evol-Instruct和Magicoder-OSS-Instruct数据集的数据，总共186,000条。最终合成的数据集称为AutoCoder-AIEV-Instruct，包含169,000条数据，共241,000轮对话。AutoCoder-AIEV-Instruct和其他数据集的case对比如下：  

{% asset_img autocoder_compare.png 数据合成 %}  

# 代码格式优化  

论文：《LLM-assisted code cleaning for training accurate code generators》  

时间：2023年11月  

这篇论文核心就在于优化已有代码数据的格式。具体来说优化3点：  
- 重命名：变量命名的优化，把一些和上下文无关的，不清晰的命名改成一看就知道是什么的名字  
- 模块化：把长代码段落split成单独的功能块，写成小函数的形式  
- planning：用原子化的函数重新组装成完整的代码，并为每个操作写上注释  

{% asset_img format_intro.png 数据合成 %}  

而这些转换都是通过ChatGPT来实现的。转换完成之后会使用测试样例进行验证，验证不通过的话最多会重试5次转换。  

1、重命名  

重命名的prompt如下：  

```python
QUESTION:
{problem_statement}
ANSWER:
‘’‘python
{solution}
’‘’
Rename the variables in the program to be descriptive, meaningful, and consistent. Do not change the original semantics of the program. Enclose the program within backticks as shown above and remember to use descriptive variable names.
```  

2、模块化  

模块化的时候，如果代码比较长，那么就执行两轮的模块化。第一轮模块化的prompt如下：  

```python
QUESTION:
{problem_statement}
ANSWER:
‘’‘python
{renamed_solution}
’‘’
Refactor the above program. Follow the guidelines:
* Make the program more modular with smaller and meaningful helper functions.
* Use good descriptive names for the helper functions.
* Have an entry function called 'main()'.
* Call 'main()' inside 'if name == 'main''.
Do not change the original semantics of the program significantly and there is no need to perform optimizations. Enclose the program within backticks as shown above.
```  

第一轮完成后，如果代码中还包含一个超过20行的函数，那么就进一步进行模块，并指出具体要分解哪些函数。实践中大约有20%~40%需要二次模块化。所用prompt：  

```python
QUESTION:
{problem_statement}
ANSWER:
‘’‘python
{modularized_solution}
’‘’
Refactor the above program by modularizing it and breaking down long and complex functions into smaller meaningful helper functions. Particularly refactor and decompose the following function(s) into smaller helper functions - {function_names_string} Only return the refactored program enclosed in backticks as shown above.
```  

3、planning  

prompt如下：  

```python
QUESTION:
{problem_statement}
ANSWER:
‘’‘python
{modularized_solution}
’‘’
Generate a summary for the following functions and classes in the program within four lines each. The summaries should be descriptive and helpful for understanding the program (however yet concise in four lines).
The functions and classes are -
{list_of_function_names}
Follow the provided format for the summaries while being informative and concise. Enclose the signatures in backticks as shown above.
```  

# Personalised Distillation  

论文：《Personalized distillation: Empowering opensourced LLMs with adaptive learning for code generation》  

时间：2023年10月  

之前获取数据的做法一般是用指令从teacher模型（比如ChatGPT）获取答案，然后用得到的指令+答案数据来训练student模型。这种方法就没有考虑到不同的student模型的现有效果和优缺点。  

而Personalised Distillation则是先让student model尝试解决问题，然后teacher model再在这个基础上提供针对性的修改，帮助student model实现个性化的学习。  

{% asset_img distill_intro.png 数据合成 %}  

具体来说，对于代码任务，如果student model已经能够解决，那么这个问题就不再需要teacher model。只有哪些student model解决不了的，才会把问题、student model的方案、执行反馈输入给teacher model，以获得改进方案，并给student model学习，这就是personalised distillation。  

直接学习teacher model的答案，和personalised distillation两种方法对比的一个例子如下：  

{% asset_img distill_example.png 数据合成 %}  

可以看到个性化蒸馏后，student model的结果和teacher model直接生成的结果还是有比较大的不同。个性化蒸馏帮助student model在自己的思路上改进，而不单单只是学习teacher model的输出。  

# 关于数据过滤  

数据过滤也是数据合成中一个重要的环节。  

## Superfiltering  

论文：《Superfiltering: Weak-to-Strong Data Filtering for Fast Instruction-Tuning https://arxiv.org/abs/2402.00530》  

时间：2024年2月  

Superfiltering通过实验发现，大模型和小模型在计算指令的IFD分数时具有一致性，因此可以用小模型通过IFD来选择指令，从而达到低成本高效果的目的。  

IFD = Instruction-Following Difficulty。IFD分数是一种用于衡量指令对模型生成回复帮助程度的指标。  

以下是一个计算IFD分数的具体例子：  

假设有一个instruction - response pair：  
- Instruction（x）：“请介绍一下苹果这种水果。”  
- Response（y）：“苹果是一种常见的水果，通常呈圆形，颜色有红色、绿色等，口感酸甜可口，富含维生素C和纤维素等营养成分。”  

使用模型计算PPL：
- 比如用规模比较小的GPT-2计算在没有instruction情况下生成该回复的PPL，$\mathrm{PPL}(y_i)$，假设计算结果=3  
- 然后使用GPT-2计算在给定指令“请介绍一下苹果这种水果。”情况下生成该回复的PPL ，$\mathrm{PPL}(y_i|x_i)$，假设计算结果=5  

然后根据IFD分数的计算公式计算IFD score：  

$$\mathrm{IFD}(y_i|x_i)=\frac{\mathrm{PPL}(y_i|x_i)}{\mathrm{PPL}(y_i)}$$  

那么这条指令的IDF = 3 / 5 = 0.6。  

一般来说，IFD 分数越低，表示指令对模型生成回复的帮助越大，该指令相对更容易被模型处理；反之，IFD 分数越高，表示指令对模型生成回复的帮助越小，指令难度相对较大。论文里选择了IFD分数高的部分数据进行训练。  

## CodeBERTScore  

论文：《CodeBERTScore: Evaluating Code Generation with Pretrained Models of Code》  

时间：2023年2月  

用代码相关指令数据，训练了5种语言（Python、C、Java、CPP、JavaScript）的Bert打分模型，在https://huggingface.co/neulab上可以下载。  

# 小结  

- 不同领域的数据合成方法也很不相同  
- 代码数据需要考虑可执行、可读性、结构化等维度  


***  

博客：[http://www.linsight.cn/](http://www.linsight.cn/)  
知乎：[Linsight](https://www.zhihu.com/people/us4ever)  
微信公众号：Linsight  
![](/images/qrcode.jpg)
博主微信号(添加请注明来意)：  
![](/images/wechat.png)  

***  

【推荐文章】  
- MoE：  
[MoE模型的前世今生](http://www.linsight.cn/44e38c1b.html)  
[DeepSeek-V2和MLA](https://www.linsight.cn/83c49df0.html)  
[昆仑万维-SkyworkMoE](https://www.linsight.cn/1d5bcd45.html)  
[成本10w刀的JetMoE](https://www.linsight.cn/f3acf042.html)  
[MoE的top-p routing](https://www.linsight.cn/224c42da.html)  
[对MoE模型的一些观察](https://www.linsight.cn/5e1d14b3.html)  
[从dense到MoE -- sparse upcycling](https://www.linsight.cn/a0824e29.html)  
[MoE路由--expert choice routing](https://www.linsight.cn/2c8bbc7.html)  
- 端侧模型：  
[苹果智能系统模型--AFM](https://www.linsight.cn/1e34e252.html)  
[MiniCPM](https://www.linsight.cn/376db710.html)  
[适合移动设备的语言模型--MobileLLM](https://www.linsight.cn/5ac36d34.html)  
[phi系列模型](https://www.linsight.cn/fe13b56f.html)  
[Gemma2](https://www.linsight.cn/cf3f1f81.html)  
[苹果的OpenELM](https://www.linsight.cn/f845f3e4.html)  
[bilibili的index-1.9B](https://www.linsight.cn/770b63e1.html)  
- 预训练：  
[代码大模型(一)--业界现状](https://www.linsight.cn/a0b50049.html)  
[代码大模型(二)--OpenCoder](https://www.linsight.cn/7856bcc1.html)  
[LLM高效预训练(一)](https://www.linsight.cn/dcb57672.html)  
[LLM高效预训练(二)](https://www.linsight.cn/1e2e35a7.html)  
[Llama3.1--预训练要点一览](https://www.linsight.cn/7d7294cb.html)  
[Qwen2技术报告](https://www.linsight.cn/a8f8b641.html)  
[Yi技术报告-划重点看细节](http://www.linsight.cn/41b6a819.html)  
[InternLM系列模型](https://www.linsight.cn/7f3d361.html)  
[GLM4报告的一些技术点](https://www.linsight.cn/a5206abd.html)  
[从Yuan2.0到Yuan2.0-M32](https://www.linsight.cn/3df0cd42.html)  
[从loss视角理解大模型涌现能力](https://www.linsight.cn/f5fb75e4.html)  
- 数据：  
[训练数据合成(一)](https://www.linsight.cn/85132189.html)  
[训练数据合成(二)](https://www.linsight.cn/2a22baeb.html)  
[LLM预训练数据策略(一)](https://www.linsight.cn/2c2cdc34.html)  
[预训练数据处理--长度分解](https://www.linsight.cn/210dbccd.html)  
- 长上下文：  
[LLM长上下文的问题](http://www.linsight.cn/c4da56c0.html)  
[解锁大模型长上下文能力](http://www.linsight.cn/cc852861.html)  
[大模型推理窗口-从有限到无限大](http://www.linsight.cn/45ee1a6d.html)  
- 推理加速：  
[大模型推理加速-投机解码](http://www.linsight.cn/f5c015c.html)  
[大模型推理加速-MEDUSA](https://www.linsight.cn/7bbe2df6.html)  
- 对齐：  
[Llama3.1--post-training要点一览](https://www.linsight.cn/93328a2a.html)  
[模型平均 -- model soup](https://www.linsight.cn/bb8fcf21.html)  
[大模型偏好对齐-DPO](http://www.linsight.cn/473f2b43.html)  
[大模型偏好对齐-ODPO](http://www.linsight.cn/da871ebe.html)  
[大模型偏好对齐-simPO](http://www.linsight.cn/280fa97a.html)  
[大模型偏好对齐-IPO](http://www.linsight.cn/4fe7b810.html)  
- Transformer：  
[理解Attention:从起源到MHA,MQA和GQA](http://www.linsight.cn/3dc22f96.html)  
[LLM的重复生成和ICL](https://www.linsight.cn/7381cae3.html)  
[transformer中normalization的二三事](http://www.linsight.cn/6a40bfa5.html)  
[从代码实现看normalization-到底做了什么](http://www.linsight.cn/b70b4a2d.html)  
[稀疏注意力计算:sliding window attention](http://www.linsight.cn/c61d17e3.html)  
[理解LLM位置编码:RoPE](http://www.linsight.cn/a051710f.html)  
[RoPE的远距离衰减](https://www.linsight.cn/f0902f1a.html)  
- 项目应用：  
[一个模型支持智能助手系统](https://www.linsight.cn/9c593ccd.html)  
- CV：  
[CV入门--关于Vision Transformer](https://www.linsight.cn/a11e2633.html)  
[CV入门--无监督学习](https://www.linsight.cn/ae81a87b.html)  
- 多模态：  
[多模态入门--CLIP](https://www.linsight.cn/3069051d.html)  
- 大模型算法题：  
[(1)](http://www.linsight.cn/3345028a.html)、
[(2)](http://www.linsight.cn/ad0bba9d.html)、
[(3)](http://www.linsight.cn/1736008.html)、
[(4)](http://www.linsight.cn/1736008.html)、
[(5)](http://www.linsight.cn/336f2f3e.html)、
[(6)](http://www.linsight.cn/7c04944d.html)、
[(7)](https://www.linsight.cn/dd614e12.html)、
[(8)](https://www.linsight.cn/e287b9c3.html)、
[(9)](https://www.linsight.cn/fb9c8882.html)  

# Reference  

【1】Mastering the Craft of Data Synthesis for CodeLLMs https://arxiv.org/pdf/2411.00005  
【2】Instruction Pre-Training: Language Models are Supervised Multitask Learners https://arxiv.org/abs/2406.14491  
【3】Automatic instruction evolving for large language models https://arxiv.org/abs/2406.00770  
【4】WaveCoder: Widespread And Versatile Enhancement For Code Large Language Models By Instruction Tuning https://arxiv.org/abs/2312.14187  
【5】SemCoder: Training Code Language Models with Comprehensive Semantics Reasoning https://arxiv.org/abs/2406.01006  
【6】AutoCoder: Enhancing Code Large Language Model with AIEV-INSTRUCT https://arxiv.org/abs/2405.14906  
【7】LLM-Assisted Code Cleaning For Training Accurate Code Generators https://arxiv.org/abs/2311.14904  
【8】Personalized distillation: Empowering opensourced LLMs with adaptive learning for code generation https://arxiv.org/abs/2310.18628  
【9】Superfiltering: Weak-to-Strong Data Filtering for Fast Instruction-Tuning https://arxiv.org/abs/2402.00530  
【10】CodeBERTScore: Evaluating Code Generation with Pretrained Models of Code https://arxiv.org/abs/2302.05527  
